// lib/smart-project-manager.ts
import { getCachedRepositories, GitHubRepository } from './github-api'
import { getCachedProjectsWithStatus } from './vercel-api'

export interface SmartProjectData {
  // Auto-populated from GitHub
  id: string
  name: string
  description: string
  githubData: {
    stars: number
    forks: number
    language: string
    topics: string[]
    lastUpdated: string
    url: string
  }
  
  // Auto-populated from Vercel
  vercelData?: {
    isLive: boolean
    liveUrl?: string
    deploymentStatus: string
  }
  
  // Auto-generated smart defaults
  autoGenerated: {
    category: 'frontend' | 'backend' | 'fullstack' | 'data' | 'mobile' | 'other'
    techStack: string[]
    featured: boolean
    deploymentScore: number
  }
  
  // User-customizable (starts with smart defaults)
  customizable: {
    customDescription?: string
    featured?: boolean // Can override auto-generated
    category?: string // Can override auto-generated
    client?: string
    teamSize?: number
    role?: string
    highlights?: string[]
    caseStudy?: {
      problem?: string
      solution?: string
      impact?: string
      metrics?: Array<{
        label: string
        value: string
        description: string
      }>
    }
    images?: string[]
    priority?: number // For ordering
  }
}

class SmartProjectManager {
  private customizations: Map<string, any> = new Map()

  // Load customizations from localStorage (for now)
  private loadCustomizations() {
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem('portfolio-customizations')
      if (saved) {
        this.customizations = new Map(JSON.parse(saved))
      }
    }
  }

  // Save customizations to localStorage
  private saveCustomizations() {
    if (typeof window !== 'undefined') {
      localStorage.setItem('portfolio-customizations', 
        JSON.stringify(Array.from(this.customizations.entries()))
      )
    }
  }

  // Intelligently determine project category
  private determineCategory(repo: GitHubRepository): SmartProjectData['autoGenerated']['category'] {
    const { language, topics = [], description = '' } = repo
    const content = `${description} ${topics.join(' ')}`.toLowerCase()

    // Check for explicit indicators
    if (topics.includes('mobile') || content.includes('mobile') || content.includes('react-native')) {
      return 'mobile'
    }
    if (topics.includes('data-science') || content.includes('machine learning') || content.includes('ai')) {
      return 'data'
    }
    if (topics.includes('api') || content.includes('backend') || language === 'Python' && !content.includes('web')) {
      return 'backend'
    }
    if (content.includes('frontend') || (language === 'JavaScript' && !content.includes('node'))) {
      return 'frontend'
    }
    if (content.includes('fullstack') || (language === 'TypeScript' && content.includes('react'))) {
      return 'fullstack'
    }

    return 'other'
  }

  // Generate smart tech stack from GitHub data
  private generateTechStack(repo: GitHubRepository): string[] {
    const techStack = new Set<string>()
    
    // Add primary language
    if (repo.language) {
      techStack.add(repo.language)
    }

    // Add technologies from topics
    const techTopics = repo.topics?.filter(topic => 
      ['react', 'nextjs', 'vue', 'angular', 'node', 'express', 'django', 
       'flask', 'mongodb', 'postgresql', 'docker', 'aws'].includes(topic.toLowerCase())
    ) || []

    techTopics.forEach(topic => {
      const techMap: Record<string, string> = {
        'nextjs': 'Next.js',
        'react': 'React',
        'vue': 'Vue.js',
        'angular': 'Angular',
        'node': 'Node.js',
        'express': 'Express',
        'django': 'Django',
        'flask': 'Flask',
        'mongodb': 'MongoDB',
        'postgresql': 'PostgreSQL',
        'docker': 'Docker',
        'aws': 'AWS'
      }
      techStack.add(techMap[topic.toLowerCase()] || topic)
    })

    return Array.from(techStack).slice(0, 6)
  }

  // Determine if project should be featured
  private shouldBeFeatured(repo: GitHubRepository): boolean {
    const score = 
      (repo.stargazers_count * 2) + 
      (repo.forks_count * 1) + 
      (repo.topics?.includes('featured') ? 10 : 0) +
      (repo.description ? 5 : 0) +
      (new Date(repo.updated_at) > new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) ? 5 : 0)
    
    return score >= 8
  }

  // Calculate deployment score
  private calculateDeploymentScore(repo: GitHubRepository, vercelData?: any): number {
    let score = 60

    if (repo.description) score += 10
    if (repo.stargazers_count > 0) score += Math.min(repo.stargazers_count * 2, 20)
    if (repo.topics && repo.topics.length > 0) score += 5
    if (vercelData?.isLive) score += 15

    const daysSinceUpdate = (Date.now() - new Date(repo.updated_at).getTime()) / (1000 * 60 * 60 * 24)
    if (daysSinceUpdate < 30) score += 10

    return Math.min(score, 100)
  }

  // Generate smart descriptions
  private generateSmartDescription(repo: GitHubRepository): string {
    const { description, language, topics = [] } = repo
    
    if (description) return description

    // Generate based on tech stack and topics
    const techStr = language ? `Built with ${language}` : 'Web application'
    const topicStr = topics.length > 0 ? ` featuring ${topics.slice(0, 2).join(' and ')}` : ''
    
    return `${techStr}${topicStr} - part of my development portfolio`
  }

  // Main method to get smart project data
  async getSmartProjects(): Promise<SmartProjectData[]> {
    this.loadCustomizations()

    const [githubRepos, vercelProjects] = await Promise.all([
      getCachedRepositories(),
      getCachedProjectsWithStatus().catch(() => [])
    ])

    const smartProjects: SmartProjectData[] = githubRepos.map(repo => {
      // FIXED: Added proper type checking and optional chaining
      const vercelData = vercelProjects.find((v: any) => 
        v?.project?.name?.toLowerCase() === repo.name.toLowerCase()
      )

      const autoGenerated = {
        category: this.determineCategory(repo),
        techStack: this.generateTechStack(repo),
        featured: this.shouldBeFeatured(repo),
        deploymentScore: this.calculateDeploymentScore(repo, vercelData?.status)
      }

      // Merge with user customizations
      const customizations = this.customizations.get(repo.name) || {}

      return {
        id: repo.id.toString(),
        name: repo.name,
        description: this.generateSmartDescription(repo),
        githubData: {
          stars: repo.stargazers_count,
          forks: repo.forks_count,
          language: repo.language || 'Unknown',
          topics: repo.topics || [],
          lastUpdated: repo.updated_at,
          url: repo.html_url
        },
        vercelData: vercelData ? {
          isLive: vercelData.status?.state === 'READY',
          liveUrl: vercelData.liveUrl,
          deploymentStatus: vercelData.status?.state || 'unknown'
        } : undefined,
        autoGenerated,
        customizable: {
          featured: customizations.featured ?? autoGenerated.featured,
          category: customizations.category ?? autoGenerated.category,
          ...customizations
        }
      }
    })

    // Sort by priority: featured first, then by deployment score
    return smartProjects.sort((a, b) => {
      const aFeatured = a.customizable.featured ?? a.autoGenerated.featured
      const bFeatured = b.customizable.featured ?? b.autoGenerated.featured
      
      if (aFeatured && !bFeatured) return -1
      if (!aFeatured && bFeatured) return 1
      
      const aPriority = a.customizable.priority ?? a.autoGenerated.deploymentScore
      const bPriority = b.customizable.priority ?? b.autoGenerated.deploymentScore
      
      return bPriority - aPriority
    })
  }

  // Update project customizations
  updateProject(projectName: string, updates: Partial<SmartProjectData['customizable']>) {
    const current = this.customizations.get(projectName) || {}
    this.customizations.set(projectName, { ...current, ...updates })
    this.saveCustomizations()
  }

  // Get single project
  async getProject(projectName: string): Promise<SmartProjectData | null> {
    const projects = await this.getSmartProjects()
    return projects.find(p => p.name === projectName) || null
  }

  // Reset customizations for a project
  resetProject(projectName: string) {
    this.customizations.delete(projectName)
    this.saveCustomizations()
  }

  // Export all customizations (for backing up)
  exportCustomizations(): string {
    return JSON.stringify(Array.from(this.customizations.entries()), null, 2)
  }

  // Import customizations
  importCustomizations(json: string) {
    try {
      const data = JSON.parse(json)
      this.customizations = new Map(data)
      this.saveCustomizations()
      return true
    } catch {
      return false
    }
  }
}

// Export singleton
export const smartProjectManager = new SmartProjectManager()

// Convenience functions
export async function getSmartProjects() {
  return smartProjectManager.getSmartProjects()
}

export async function getSmartProject(name: string) {
  return smartProjectManager.getProject(name)
}

export function updateProjectCustomization(name: string, updates: any) {
  return smartProjectManager.updateProject(name, updates)
}